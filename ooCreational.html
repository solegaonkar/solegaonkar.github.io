<!DOCTYPE html><html><head><title>Creational Pattern</title><script src='scripts/index.js'></script></head><body><h1>Creational Pattern</h1><hr/><p><a href="">TheWiz.Net</a></p>

<p>Creational patterns are ones that create objects for you, rather than having you instantiate objects directly. This gives your program more flexibility in deciding which objects need to be created for a given case.</p>

<h3>Factory Method</h3><hr/><p>This is the most fundamental creational pattern. All others are extensions of this pattern.</p><p>Most object oriented programming languages provide a new operator (or its equivalent) that is used to instantiate an object of the given class. This is the simplest way of creating instances (the Java reflection API can be used to create instances - but that is certainly not simple)</p><p>But there are occasions when it is important to control the instantiation. We might want to ensure instantiation in groups, or we want to limit the number of objects, we want to simplify the API . . There are many different scenarios when we need to do this. In such a case, the new operator gives away the control to the caller and then it is very difficult to ensure that we live up to the constraints. </p><p>The Factory Method is meant to take care of such scenarios. Essentially, Factory method is a method that takes care of instantiating the object. It contains the complexity of instantiation and any other functionality that goes along with it.</p><p>Factory method or any creational pattern does not mean that we have a good design. The Factory Method is not necessarily the best way of creating instances. The "new" operator is usually the best way of doing the job - that is why languages provide it. It is important to understand when and which creational pattern is required.</p>

<h3>Singleton</h3><hr/><p>This is one of the simplest of the Creation Patterns. Singleton is a class that has only one instance - and cannot have more instances. This is useful when we want to contain a consistent functionality for the entire application.</p><p>Most programming languages do not provide a direct support for this functionality. Any code with visibility to a class can instantiate it to get an object - using the new operator. For ensuring that a class has only one instance, we have to ensure that nobody can invoke the constructor. To ensure this, the constructor has to be a private member of the class. </p><p>With this in place, we can provide a method that helps a caller with the instance of the class. This method has to make sure that it allows only one instance and returns the same instance if there are multiple calls to the method. Often this needs to be thread safe.</p><p>Thus, the getInstance() is a public static method that returns the only object of the class. Now the question is, when is  this single object created? Typically there are two implementations for this - eager and lazy. The eager implementation instantiates the object much before it is required - perhaps in a static block. The lazy implementation does this only on the first call to the getInstance() method.</p>

<h3>Builder</h3><hr/><p>One of the principles of good design is that we do not crunch too much complexity into a single unit of the code, and any unit of the code is always focused on a consistent isolated part of the functionality. This is the core inspiration behind the Builder pattern.</p><p>If we want a class to be extremely configurable, the process of construction gets complicated too. There are two ways of doing this - either have a complex constructor that takes in a parameter and interprets it into the various configuration parameters. Or we have the invoking code use setters to configure each part. </p><p>Both approaches are bad. When the class itself has intense functionality, the constructor should not be so complex. And having the process of configuration spread all over the code makes it impossible to maintain.</p><p>The builder pattern is the best way of handling such a scenario. Here, we implement another "Builder" class that takes care of instantiating and configuring the objects of  the given class. The Builder class provides a Factory method that takes returns a configured object based on the input parameter. That separates the complexity of construction from the complexity of functionality. Also, it ensures that the complexity of configuration is localized and easy to maintain.</p>

<h3>Prototype</h3><hr/><p>This creational pattern addresses another design problem. There are times when instantiating an object is a very costly operation. It is not possible to go through the entire process again and again. At the same time, we do need many instances of the class. The Prototype pattern is used to address such constraints.</p><p>Prototype is based on cloning. The Factory class contains individual instances of the different configurations of the product class. Based on the parameters passed to the factory method, it clones the particular object and passes on an instance. </p><p>Now here is the catch. How deep should we clone it? We chose cloning because we wanted it to be easier and faster. But if the cloning itself gets complicated, then we are defeating the purpose. On the other hand, if we make a very shallow clone, then we defeat the purpose of cloning itself!</p><p>That depends upon the required functionality. Prototype is very useful when the actual object is trivially simple, but it requires extreme processing to instantiate. We can avoid that processing by using a prototype pattern.</p><p>Consider for example, if we are working on implementing an image processing algorithm. If we want to an object that contains the convolution matrix built out of these images. We want to use this matrix to perform a lot more processing. It is a meaningless effort to rework the convolutions again and again. Also, it is not possible to do all the processing on one instance of this matrix - because the processing will destroy the current data. The Prototype pattern can help us solve such a problem.</p><p>The Prototype holder can evaluate the matrices for once and hold  them within it. On every call to the factory method, it can return a cloned copy of this matrix. The caller can then mess with this copy without disrupting what is contained in the container. Next time we need the matrix, we can just invoke the factory method once again.</p>

<h3>Abstract Factory</h3><hr/><p>The Abstract Factory pattern is another level of abstraction above the Factory pattern. The Factory pattern provides for a Factory object that can be used to instantiate product objects based on the parameters. The Factory Method returns objects that are instances of the abstract product class.</p><p>But Abstract Factory takes this a level further. Here, the Factory itself is an instance of an abstract factory class - contained in it. </p><p>The client invokes factory method in the container abstract factory. Based on the parameter, this in turn invokes the factory method in one of the concrete factory classes. This generates the object that is returned to the client</p>

</body><script>loadPageFormat();</script></html>
