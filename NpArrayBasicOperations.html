<!DOCTYPE html><html><head><title>Numpy Arrays - Basic Operations</title><script src='scripts/index.js'></script></head><body><h1>Numpy Arrays - Basic Operations</h1><hr/>

<p>Of course, NumPy provides tons of methods for different kinds of operations on arrays. NumPy flows fluidly over scalar as well as matrix methods. That simplifies the syntax to a great extent, making the code very intuitive and easy to read.</p><h3>Scalar Functions</h3><hr/><p>Scalar operations like arithmetic operations apply directly to individual elements. We can check these out below. Let us start with creating two different arrays of size 4.</p><pre><code class='python'>&gt;&gt;&gt; a = np.array( [20,30,40,50] )
&gt;&gt;&gt; a
array([20, 30, 40, 50])
&gt;&gt;&gt; b = np.arange( 4 )
&gt;&gt;&gt; b
array([0, 1, 2, 3])</code></pre><p>Any scalar operation on the array is distributed over all the elements. For example:</p><pre><code class='python'>&gt;&gt;&gt; b + 2
array([12, 23, 34, 45])</code></pre><p>This is not limited to the plain algebraic of addition and subtraction. It can be extended to various others</p><pre><code class='python'>&gt;&gt;&gt; 10*np.sin(a)
array([ 9.12945251, -9.88031624,  7.4511316 , -2.62374854])

&gt;&gt;&gt; a&lt;35
array([ True, True, False, False])</code></pre><p>Similarly, scalar operations on two arrays apply to corresponding elements.</p><pre><code class='python'>&gt;&gt;&gt;  a * b
array([0, 30, 80, 150])

&gt;&gt;&gt; a / b
array([ 0.        ,  0.05      ,  0.06666667,  0.075     ])

&gt;&gt;&gt; a // b
array([0, 0, 0, 0], dtype=int32)</code></pre><p>This is not limited to these basic arithmetics. It can be extended to other operations as well.</p><pre><code class='python'>&gt;&gt;&gt; b ** a
array([    1,    20,   900, 64000], dtype=int32)

&gt;&gt;&gt; b += a
&gt;&gt;&gt; b
array([10, 21, 32, 43])</code></pre><p>Note that a * b leads to multiplication of the corresponding elements of the two arrays. Not a dot product. NumPy provides other methods for handling linear algebra operations.</p><h3>Unary Operations</h3><hr/><p>Simple unary operations are available for NumPy arrays.</p><pre><code class='python'>&gt;&gt;&gt; a = np.random.random((2,3))
&gt;&gt;&gt; a
array([[ 0.18626021,  0.34556073,  0.39676747],
       [ 0.53881673,  0.41919451,  0.6852195 ]])
&gt;&gt;&gt; a.sum()
2.5718191614547998
&gt;&gt;&gt; a.min()
0.1862602113776709
&gt;&gt;&gt; a.max()
0.6852195003967595</code></pre><h3>Linear Algebra</h3><hr/><p>Linear algebra defines some operations on metrices. Dot product, matrix inverse are commonly used in AI. NumPy provides a good solution for commonly used matrix operations.</p><p>As we saw above, A * B calculates the product by multiplying corresponding elements. In order to calculate the dot product, we can use either of the two</p><pre><code class='python'>&gt;&gt;&gt; A = np.array( [[1,1],
...             [0,1]] )
&gt;&gt;&gt; B = np.array( [[2,0],
...             [3,4]] )
&gt;&gt;&gt; A @ B          # Works only for Python Version &gt; 3.5
array([[5, 4],
       [3, 4]])
&gt;&gt;&gt; A.dot(B)                    
array([[5, 4],
       [3, 4]])</code></pre><p>We can get a matrix transpose by swapping the rows and columns of all elements in a for loop. But NumPy helps us get a matrix transpose. This is a lot faster than the loop.</p><pre><code class='python'>&gt;&gt;&gt; a = np.array([[1.0, 2.0], [3.0, 4.0]])
&gt;&gt;&gt; a.transpose()
array([[ 1.,  3.],
       [ 2.,  4.]])</code></pre><p>Identifying a matrix inverse is a massive task. NumPy offers methods that help speed it up to a great extent.</p><pre><code class='python'>&gt;&gt;&gt; np.linalg.inv(a)
array([[-2. ,  1. ],
       [ 1.5, -0.5]])</code></pre><p>We can also solve the equation A @ x = y to find the value of x.</p><pre><code class='python'>&gt;&gt;&gt; y = np.array([[5.], [7.]])
&gt;&gt;&gt; np.linalg.solve(a, y)
array([[-3.],
       [ 4.]])</code></pre><p>Another major computationally expensive task is computation of the Eigen Vectors. NumPy provides a single command solution for it.</p><pre><code class='python'>&gt;&gt;&gt; np.linalg.eig(j)
(array([ 0.+1.j,  0.-1.j]), array([[ 0.70710678+0.j        ,  0.70710678-0.j        ],
       [ 0.00000000-0.70710678j,  0.00000000+0.70710678j]]))</code></pre>

</body><script>loadPageFormat();</script></script></html>
