<!DOCTYPE html><html><head><title>Decorator Pattern</title><script src='scripts/index.js'></script></head><body><h1>Decorator Pattern</h1><hr/><p><a href="">TheWiz.Net</a></p>

<p>As the name suggests, a Decorator "decorates" a class. The code is pretty similar to a container class. But the concept is different. A decorator is used when we want to add a lot more functionality to the given class - that does not make a case for inheritance. </p><p>Note that inheritance is used only when we have a genuine "Is a" relationship. When we just want to add more functionality, we should use a decorator. This essentially contains the original class object and adds more functionality to it. The calls are passed over to the contained class - perhaps with some more logic before and after it. The decorator can also have its own methods.</p><p>To elaborating again, that is exactly what we do with inheritance. But we should use decoration rather than inheritance when the extension does not merge well in the class hierarchy. For example, consider the hierarchy - Shape - Polygon - Quadrilateral - Rectangle - Square.</p><p>Now if we have a "Yellow Rectangle", it does not fit well in this hierarchy. The language does not prevent us from using inheritance here. But, the design principles do. Instead, here we should use a decorator class - Yellow Shape - that can have a hierarchy of its own. The Yellow Rectangle would contain an object of class Rectangle.</p><h3>Participants</h3><hr/><p>The Decorator pattern has four participants:</p><ul><li>Component - Defines the interface for objects that can have responsibilities added to them dynamically.</li><li>ConcreteComponent - Defines an object to which additional responsibilities can be attached.</li><li>Decorator - Maintains a reference to a Component object and defines an interface that conforms to Component's interface.</li><li>ConcreteDecorator - Adds responsibilities to the component.</li></ul>

</body><script>loadPageFormat();</script></html>
