<!DOCTYPE html><html><head><title>Creating an Array</title><script src='scripts/index.js'></script></head><body><h1>Creating an Array</h1><hr/>

<p>There are two primary ways of creating a NumPy array object.</p><h3>From Python Data Types</h3><hr/>The np.array() constructor can digest any Python list / tuple to generate a new array object.<pre><code class='python'>&gt;&gt;&gt; a = np.array([2,3,4])
&gt;&gt;&gt; a
array([2, 3, 4])</code></pre><p>OR</p><pre><code class='python'>&gt;&gt;&gt; b = np.array([1.2, 3.5, 5.1])
&gt;&gt;&gt; b.dtype
dtype('float64')</code></pre><p>There is a difference  between passing in a tuple / array and passing in multiple elements (trying to imply an array).</p><pre><code class='python'>&gt;&gt;&gt; a = np.array(1,2,3,4)    # WRONG
&gt;&gt;&gt; a = np.array([1,2,3,4])  # RIGHT</code></pre><p>The array transforms sequences of sequences into two-dimensional arrays, sequences of sequences of sequences into three-dimensional arrays, and so on.</p><pre><code class='python'>&gt;&gt;&gt; b = np.array([(1.5,2,3), (4,5,6)])
&gt;&gt;&gt; b
array([[ 1.5,  2. ,  3. ],
       [ 4. ,  5. ,  6. ]])</code></pre><p>By default, it picks the data type to be the broadest type that fits all the elements. We can also provide a data type explicitly. In such a case, all the elements are force-cast to the provided data type.</p><pre><code class='python'>&gt;&gt;&gt; c = np.array( [ [1,2], [3,4] ], dtype=complex )
&gt;&gt;&gt; c
array([[ 1.+0.j,  2.+0.j],
       [ 3.+0.j,  4.+0.j]])</code></pre><h3>From NumPy Utility Functions</h3><hr/><p>There are some arrays that are used in many situations - either as initializers, or actual values to be utilized in the computation. For example, vectors with all 0's, all 1's, identity vectors, etc are repeatedly used in computation. Hence NumPy provides utility methods for that.</p><p>To create a multidimensional array of all 0's</p><pre><code class='python'>&gt;&gt;&gt; np.zeros( (3,4) )
array([[ 0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.]])</code></pre><p>Or we can create an array of all 1's</p><pre><code class='python'>&gt;&gt;&gt; np.ones( (2,3,4), dtype=np.int16 )                # dtype can also be specified
array([[[ 1, 1, 1, 1],
        [ 1, 1, 1, 1],
        [ 1, 1, 1, 1]],
       [[ 1, 1, 1, 1],
        [ 1, 1, 1, 1],
        [ 1, 1, 1, 1]]], dtype=int16)</code></pre><p>We can also generate the identity matrix using the eye() method.</p><pre><code class='python'>&gt;&gt;&gt; np.eye(2) # unit 2x2 matrix; "eye" represents "I"
array([[ 1.,  0.],
       [ 0.,  1.]])</code></pre><p>Or we can also create an array of uninitialized (junk) values</p><pre><code class='python'>&gt;&gt;&gt; np.empty( (2,3) )                                 # uninitialized, output may vary
array([[  3.73603959e-262,   6.02658058e-154,   6.55490914e-260],
       [  5.30498948e-313,   3.14673309e-307,   1.00000000e+000]])</code></pre><p>We can also generate random values using the np.rand() method</p><pre><code class='python'>&gt;&gt;&gt; np.random.random((2,3))
array([[ 0.53579825,  0.93607836,  0.19139396],
       [ 0.61408155,  0.75616037,  0.92643963]])
array([[  3.73603959e-262,   6.02658058e-154,   6.55490914e-260],
       [  5.30498948e-313,   3.14673309e-307,   1.00000000e+000]])</code></pre><p>Numpy allows us to create an array from a range of values. This is similar to the range() method of core Python. But this is a lot faster.</p><pre><code class='python'>&gt;&gt;&gt; np.arange( 10, 30, 5 )
array([10, 15, 20, 25])
&gt;&gt;&gt; np.arange( 0, 2, 0.3 )                 # it accepts float arguments
array([ 0. ,  0.3,  0.6,  0.9,  1.2,  1.5,  1.8])</code></pre><p>We have a potential problem out here. When we use floating point arguments for the arange, the output may not be exactly as one would guess. This is because of the finite floating point precision. Hence we prefer to use linespec that suggests the number of values between the end points.</p><pre><code class='python'>&gt;&gt;&gt; np.linspace( 0, 2, 9 )                   # 9 numbers in range 0 and 2.
array([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ,  1.25,  1.5 ,  1.75,  2.  ])</code></pre><h3>Custom Values</h3><hr/><p>The examples above used standard trivial values to fill the elements of the array. At times, the job is not so simple. NumPy also helps us generate an array based on a sequence of values provided by a function.</p><pre><code class='python'>&gt;&gt;&gt; def f(x,y):
...     return 10*x+y
...
&gt;&gt;&gt; np.fromfunction(f,(5,4),dtype=int)
array([[ 0,  1,  2,  3],
       [10, 11, 12, 13],
       [20, 21, 22, 23],
       [30, 31, 32, 33],
       [40, 41, 42, 43]])</code></pre>




</body><script>loadPageFormat();</script></script></html>
