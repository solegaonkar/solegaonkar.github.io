<!DOCTYPE html><html><head><title>Collections Interfaces</title><script src='scripts/index.js'></script></head><body><h1>Collections Interfaces</h1><hr/>

<p>The Java collections framework consists of several interfaces and their implementations. Here are some of the most important interfaces that define the collections framework.</p><h3><a href='https://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html'>Iterable</a></h3><hr/><p>Iterable makes an object a valid target for a for-each loop. It has a method iterator() that returns the Iterator object that can be used for iterating over the Iterable - using the hasNext() and getNext() methods. This is the base interface for the collections in Java - because it enables the user to iterate through the elements in the collection.</p><h3><a href='https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html'>Collection</a></h3><hr/><p>This is the root interface of the entire collections hierarchy. As the name suggests, it enables the object to hold a collection of elements. It exports methods to add, remove elements; to check the size or to check if a given elements is already a part of the collection. Ofcourse it also provides for iterating over the elements. Collection also exports method to extract all its elements into a java array.</p><h3><a href='https://docs.oracle.com/javase/8/docs/api/java/util/List.html'>List</a></h3><hr/><p>This interface defines an ordered collection. List does not prevent duplicate elements. Apart from the inherited collection methods, List enables accessing elements based on their index.</p><h3><a href='https://docs.oracle.com/javase/8/docs/api/java/util/Set.html'>Set</a></h3><hr/><p>A set is a collection with no duplicates. Duplicate need not mean identical. Any two objects o1 and o2 are considered duplicate if o1.equals(o2) returns true. It is expected that the return value of the equals method does not change while the elements are in the set. Else the behavior is not predictable.</p><h3><a href='https://docs.oracle.com/javase/8/docs/api/java/util/Queue.html'>Queue</a></h3><hr/><p>This interface provides for a collection tailored to hold elements prior to processing. Typically they are sequenced in a particular order (not necessarily FIFO) - depending upon the particular implementation of the queue. The Queue provides for two sets of method to add and get elements from the queue. One set throws an exception when it reaches the end - add(Element e), remove(), element(). The other does not throw an exception, but returns a special value to denote the end - offer(Element e), poll(), peek(). Most queues provide FIFO. But that is not a requirement. Priority queues and stacks are also Queues in Java.</p><h3><a href='https://docs.oracle.com/javase/8/docs/api/java/util/Map.html'>Map</a></h3><hr/><p>This interface provides an object that maps keys to values. A Map interface provides three views to its data - a set of keys, a collection of values and set of key-value mappings. Caution is required if the Keys are mutable. The behavior of a map is not defined if the value of an object is changed in a manner that affects comparisons while the object is a key in the map. A special case of this prohibition is that it is not permissible for a map to contain itself as a key. While it is permissible for a map to contain itself as a value, extreme caution is advised: the equals and hashCode methods are no longer well defined on such a map. Some map operations which perform recursive traversal of the map may fail with an exception for self-referential instances where the map directly or indirectly contains itself. This includes the clone(), equals(), hashCode() and toString() methods. Implementations may optionally handle the self-referential scenario, however most current implementations do not do so.</p><h2>Sub Interfaces</h2><hr/><p>There are several sub-interfaces that add value to the above four. These are detailed below.</p><h3><a href='https://docs.oracle.com/javase/8/docs/api/java/util/SortedSet.html'>SortedSet</a></h3><hr/><p>This interface additionally provides for ordering on its elements - as per the natural order or the defined comparator. All the elements in this set must implement the Comparable interface, or must be accepted by the specified comparator. SortedSet provides for additional methods to access the sorted elements (first(), last(), headSet(E toElement), subSet(E fromElement, E toElement), tailSet(E fromElement)).</p><h3><a href='https://docs.oracle.com/javase/8/docs/api/java/util/NavigableSet.html'>NavigableSet</a></h3><hr/><p>The NavigableSet extends the SortedSet. It provides additional functionality to navigate through the elements - access random elements in the set, etc.</p><h3><a href='https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html'>BlockingQueue</a></h3><hr/><p>BlockingQueue is a Queue that additionally supports operations that wait for the queue to become non-empty when retrieving an element, and wait for space to become available in the queue when storing an element. Apart from the 6 access methods of Queue, a BlockingQueue provides 4 more methods that either block (put(e), take()) or time out (offer(e, time, unit), poll(time, unit)) on reaching the end. Of course, this should be Thread Safe and provide consistent memory.</p><h3><a href='https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingDeque.html'>BlockingDeque</a></h3><hr/><p>This interface extends the BlockingQueue as well as the DQueue interfaces. It combines the synchronization methods of BlockingQueue with the bidirectional methods of Dequeue.</p><h3><a href='https://docs.oracle.com/javase/8/docs/api/java/util/Deque.html'>Deque</a></h3><hr/><p>This interface defines a Queue that can take in elements from either end. It provides 12 additional methods to add and remove from either end and to use this 3 methods for using it as a stack - addFirst(e), offerFirst(e), addLast(e), offerLast(e), removeFirst(), pollFirst(), removeLast(), pollLast(), getFirst(), peekFirst(), getLast(), peekLast(), push(e), pop(), peek()</p><h3><a href='https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/TransferQueue.html'>TransferQueue</a></h3><hr/><p>This interface provides a BlockingQueue in which producers may wait for consumers to receive elements. A TransferQueue may also be queried, via hasWaitingConsumer(). TransferQueue may be capacity bounded. If so, an attempted transfer operation may initially block waiting for available space, and/or subsequently block waiting for reception by a consumer. Note that in a queue with zero capacity, such as SynchronousQueue, put and transfer are effectively synonymous.</p><h3><a href="https://docs.oracle.com/javase/8/docs/api/java/util/SortedMap.html">SortedMap</a></h3><hr/><p>This interface provides a Map that further with keys ordered according to the natural ordering of its keys, or by a Comparator typically provided at sorted map creation time. This order is reflected when iterating over the sorted map's collection views (returned by the entrySet, keySet and values methods). Several additional operations are provided to take advantage of the ordering.</p><h3><a href='https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentMap.html'>ConcurrentMap</a></h3><hr/><p>This interface is used for providing thread safety and atomicity guarantees. It provides for additional methods that enable a timeout, wait, etc in case of a conflict.</p><h3><a href='https://docs.oracle.com/javase/8/docs/api/java/util/NavigableMap.html'>NavigableMap</a></h3><hr/><p>This interface provides for a SortedMap extended with navigation methods returning the closest matches for given search targets. This has methods to access and traverse the entries in ascending as well as descending order.</p>

</body><script>loadPageFormat();</script></script></html>
